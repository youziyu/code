<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>今天天气不错</title>
  <!--<script src="script.js">-->
  <!--//在外链式引用的script标签内书写代码，没有作用-->
  <!--//注意不要在这里书写代码-->
  <!--//console.log("哈哈");-->
  <!--</script>-->
  <script>
    //内嵌式
    
    //变量的三个操作
    //1 声明
    //    var num;
    //不规范的操作
    //声明不加var，多个声明的不规范写法var a = b = c =3;
    
    //2 赋值
    //    var num;
    //    num = 100;
    //3 初始化
    //    var num = 100;
    
    
    //变量的作用：存储数据
    //临时数据保存在内存中
    //基本类型在内存中的保存：基本类型在内存单元中保存的是具体值
    //复杂类型在内存中保存：保存的是真正的数据的指针（引用，箭头）
    
    //基本数据类型5个：number string boolean undefined null
    //console.log(typeof null);
    ////null的作用，内部保存的是一个空指针
    //var obj = null;
    //var obj1;
    //var arr = [1,2,3];
    
    //console.log(typeof arr);
    
    //var obj = {
    //  name: "张三"
    //};
    //console.log(Object.prototype.toString.call(null));
    //console.log(Object.prototype.toString.call(obj));
    
    
    //逻辑运算符
    //&& || !
    //当操作数均为bool类型时：
    //&&：当两个操作数都为true返回true，一个为false返回false
    //||：当两个操作数都为false，返回false，否则返回true
    //!：取反
    
    //当操作数不是bool值时：
    //console.log(100 && "a");
    //1 从左往右看
    //2 如果操作数不是bool值，转换为bool值
    //3 根据当前bool值去判断，如果这个操作数可以决定式子的结果，返回这个源操作数
    //4 决定不了结果，继续看第二个操作数
    
    //console.log(100 || 0);
    
    // ifelse 适用于范围判断
    //单if 适用于1种情况
    //    var age = 19;
    //    if (age > 18) {
    //      alert("可以看电影");
    //    }
    
    //ifelse  适用于两种情况
    //    if(age>18){
    //      alert("可以看电影");
    //    }else{
    //      alert("可以看动画片");
    //    }
    
    //if elseif elseif...else 适用于多种情况
    
    // switchcase 适用于单值判断
    //var num = 78;
    //switch (true){
    //  case num<90:
    //    alert("低于90");
    //    break;
    //  case 90:
    //    alert("值为90");
    //    break;
    //}
    
    //for 适用于有规律，有次数限制的重复执行代码
    //1 计算1-100的和
    //    var sum = 0;
    //    for (var i = 1; i <= 100; i++) {
    //      sum += i;
    //    }
    
    //while 适用于无规律，次数不定的重复执行代码
    //do..while 与while的区别，第一次执行时不进行条件判断
    //    do{
    //      console.log("1>3么？");
    //    }while(1>3);
    
    
    //数组的作用：保存多个数据
    //var arr = new Array(1,2,3);
    //    var arr = [1, 2, 3, 4, 5, 6];
    //arr.length 获取数组的元素个数
    //console.log(arr.length);
    //数组中的与元素按照索引排列，索引从0开始
    
    //长度和索引的关系
    //数组中最后一个元素的索引值 arr.length-1
    //数组中新项的索引值 arr.length
    
    //数组length属性的使用
    //当设置的长度大于原数组的元素个数
    //arr.length = 10;//一般不会这么做,因为数组中的元素没有真正增加，多出来的元素值为undefined
    //设置的长度小于原数组的元素个数
    //arr.length = 3;
    //console.log(arr);//多余的元素会被删除，并且是彻底删除
    
    //使用length的操作
    //清空数组 arr.length = 0;
    //删除最后一个元素 arr.length = arr.length-1;
    
    //数组的两个基本操作
    //正向遍历:使用for循环去获取数组中的每个元素
    //    var arr = [1, 2, 3, 4, 5, 6];
    //    //    for (var i = 0; i <= arr.length - 1; i++) {
    //    for (var i = 0; i < arr.length; i++) {
    //      // i相当于索引值
    //      console.log(arr[i]);
    //    }
    
    //反向遍历
    //    for (var i = arr.length - 1; i >= 0; i--) {
    //      console.log(arr[i]);
    //    }
    
    //冒泡排序
    //    var arr = [1, 2, 3, 4, 5, 7, 6];
    //    var count = 0;
    //    //1 外层循环控制轮数 arr.length - 1
    //    for (var i = 0; i < arr.length - 1; i++) {
    //      count++;
    //      var flag = true;//假设当前这一轮可以跳出
    //
    //      //2 内层循环控制次数 arr.length - 1 - i
    //      for (var j = 0; j < arr.length - 1 - i; j++) {
    //        //3 比較当前项和后项的大小
    //        if (arr[j] > arr[j + 1]) {
    //          var temp = arr[j];
    //          arr[j] = arr[j + 1];
    //          arr[j + 1] = temp;
    //          //如果进入if，说明当前项小于后项，这时不能结束排序
    //          flag = false;
    //        }
    //      }
    //      //根据假设条件判断是否可以跳出
    //      if (flag) {
    //        break;
    //      }
    //    }
    //    console.log(arr);
    //    console.log(count);
    
    //类型检测
    //var arr = [1,2,3];
    //console.log(Array.isArray(arr));//true
    //console.log(arr instanceof Array);//true
    //console.log(Object.prototype.toString.call(arr));// "[object Array]"
    
    
    //函数的作用：重用
    //    function fun(){
    //      console.log("今天天气不错");
    //    }
    //    //函数的调用
    //    fun();
    //    fun();
    //    fun();
    
    
    //当函数的大体功能一定，但是某些值不确定时，可以传入参数
    //函数体内的参数称为形参，形参必须写在函数体的小括号中
    //形参相当于函数的变量，不需要进行声明
    function getSum(n, m) {
      var sum = 0;
      for (var i = n; i <= m; i++) {
        sum += i;
      }
      //给函数设置返回值，可以让函数外得到函数的计算结果
      //如果函数没有设置返回值，值为undefined
      //return的第二个作用，跳出函数
      //一个函数只能设置一个返回值
      return sum;
//      alert("我会执行么？呵呵不会")
    }
    //在函数调用语句中传入对应的实参
    //返回值的接受，通过函数调用语句进行接受
    //    var result1 = getSum(100, 200);
    //    var result2 = getSum(1, 100);
    //    console.log(result1 + result2);
    
    
    //作用域
    //1 全局作用域：函数外，不在任何的函数内
    //2 局部作用域：函数内
    
    //全局变量：在全局作用域下声明的变量，在全局任意位置可以使用（全局作用域和局部作用域都可以访问）
    //局部变量：在函数内声明的变量，只能在当前声明的这个局部作用域内部访问
    //    function fun() {
    //      var num = 100;
    //      function fun2(){
    //        console.log(num);
    //      }
    //      fun2();
    //    }
    //    fun();
    
    //作用域链的访问规则
    //    function fun() {
    ////      var num = 100;
    //      function fun2() {
    //        //直接使用值
    //        //如果当前作用域下没有num的声明，向父级查找，如果每个父级都没有，最终找到全局作用域，如果还没有，报错
    //        //console.log(num);
    //
    //        //赋值
    //        //如果当前作用域下没有num的声明，向父级查找，如果每个父级都没有，最终找到全局作用域，如果还没有，声明一个全局变量num
    //        num = 100;
    //      }
    //
    //      fun2();
    //    }
    //    fun();
    
    //预解析
    //每个作用域开始的时候都会发生预解析
    //1 找到当前作用域内的var变量声明语句，将变量声明语句提升到当前作用域顶端，赋值语句保留在原地
    //    var sum;
    //    //2 找到当前作用域内的function函数声明语句，将函数体整体提升到作用域顶端，调用语句保留在原地
    //    function fun() {
    //      var num = 100;
    //    }
    //    //3 以上两种提升不分先后
    //
    //    //----------------
    //    sum = 1000;
    //    fun();
    //    fun();
    
    
    //    num = 10;
    //    var num = 100;
    //    console.log(num);
    
    //    var num = 100;
    //    var num;
    //    console.log(num);//100
    
    
    //变量和函数重名
    //变量有值取变量，变量没有值取函数体
    //    var a;
    //    function a() {
    //
    //    }
    //
    //    console.log(a);//function函数体
    
    
    //    var a = 100;
    //    function a() {
    //
    //    }
    //    console.log(a);//100
    
    
    //回调函数：将函数作为参数传递给另一个函数
    //当函数内某些值不确定，这时传入普通的参数
    //当函数内的某些功能不确定，传入函数参数
    
    //1 传入函数参数第一步要求必须分析传参过程
    //    function getSum(n, m, fn) {
    //      //n=1;
    //      //m=100;
    //      //fn = function fun(sum) {
    //      //  console.log("最终的计算结果是" + sum)
    //      //}
    //      var sum = 0;
    //      for (var i = n; i <= m; i++) {
    //        sum += i;
    //      }
    //      fn(sum);
    //      return sum;
    //    }
    //
    //    getSum(1, 100, fun);
    //    getSum(2, 300, function (sum) {
    //      console.log("最终的计算结果是" + sum)
    //    });
    //
    //    function fun(sum) {
    //      console.log("最终的计算结果是" + sum)
    //    }
    
    
    //函数的多种声明方式
    //1 函数声明语句
    //function fun(){
    //
    //}
    
    //2 函数表达式
    //console.log(fun);//undefined，不能进行调用
    //var fun = function () {
    //
    //};
    
    
    //3 匿名函数：没有名字的函数，不能单独使用
    //3.1 将匿名函数保存在一个变量中
    //3.2 作为参数使用
    //3.3 自调用函数（立即执行函数）
    
    //    (function () {
    //      //自调用函数只能在书写的位置执行一次
    //      //减少全局变量的使用
    //      var num = 100;
    //      console.log(num + 100);
    //    })();
    
    
    //对象：对象是一种数据存储形式
    //var obj = new Object();  //var arr = new Array();
    //var obj = {};            //var arr = [];
    
    //给对象添加属性和方法
    //    var obj = new Object();
    //    obj.name = "张三";
    //    obj.sayHi = function () {
    //
    //    };
    //    //使用对象的属性和方法时必须要先执行这个属性或方法属于哪个对象
    //    console.log(obj.name);
    //    obj.sayHi();
    
    
    //通过函数创建多个对象
    function createStu(name) {
      //1 创建对象
      var stu = new Object();
      //2 设置属性和方法
      stu.name = name;
      stu.sayHi = function () {
        //        console.log("我是" + stu.name);
        console.log("我是" + this.name);
      };
      //3 返回对象
      return stu;
    }
    //    var zS = createStu("张三");
    //    console.log(zS.name);
    //
    //    var lS = createStu("李四");
    //    console.log(lS.name);
    
    
    //使用构造函数创建对象
    //1 构造函数的命名，首字母大写
    //2 调用的时候加new：new帮我们创建了一个对象，将构造函数内的this指向新创建的对象，并且返回了这个对象
    //3 我们在构造函数内需要给新创建的对象添加属性和方法
    
    //    function Create() {
    //      //设置属性和方法
    //      this.name = "张三";
    //      this.sayHi = function () {
    //        console.log("你好我是:" + this.name);
    //      };
    //    }
    //
    //    var stu = new Create();
    //    console.log(stu);
    //    console.log(stu.name);
    //    stu.sayHi();
    //
    
    //对象字面量的使用
    var obj = {
      name: "张三",
      age: 18,
      sayHi: function () {
        console.log("呵呵");
      }
    };
    
    //    console.log(obj.name);
    //    obj.color = "red";
    
    //对象的属性访问的两种方式
    //console.log(obj.name);
    //console.log(obj["na" + "me"]);
    
    
    //对象的遍历方式
    //k 代表属性名 - 字符串类型
    //obj 代码要遍历的对象
    //obj[k] 访问k所代表的属性的值
//    for (var k in obj) {
//      console.log(obj[k]);
//    }
    
    //数据存储形式 JSON
//    var json = {
//      "name":"张三",
//      "age":18
//    };
//
//    for(var k in json){
//      console.log(json[k]);
//    }
  
  
  </script>
</head>
<body>
<!--<div onclick="alert(1)"></div>-->

</body>
</html>